const getHeapAudioBuffer = () => {
    class HeapAudioBuffer {
        /**
         * @constructor
         * @param  {object} wasmModule WASM module generated by Emscripten.
         * @param  {number} length Buffer frame length.
         * @param  {number} channelCount Number of channels.
         * @param  {number=} maxChannelCount Maximum number of channels.
         */
        constructor(wasmModule, length, channelCount, maxChannelCount) {
            // The |channelCount| must be greater than 0, and less than or equal to
            // the maximum channel count.
            this._isInitialized = false;
            this._module = wasmModule;
            this._length = length;
            this._maxChannelCount = maxChannelCount
                ? Math.min(maxChannelCount, MAX_CHANNEL_COUNT)
                : channelCount;
            this._channelCount = channelCount;
            this._allocateHeap();
            this._isInitialized = true;
        }

        /**
         * Allocates memory in the WASM heap and set up Float32Array views for the
         * channel data.
         *
         * @private
         */
        _allocateHeap() {
            const dataByteSize = this._channelCount * this._length * BYTES_PER_SAMPLE;
            this._dataPtr = this._module.stackAlloc(dataByteSize);
            this._channelData = [];
            for (let i = 0; i < this._channelCount; ++i) {
                // convert pointer to HEAPF32 index
                let startOffset = this._dataPtr / BYTES_PER_SAMPLE + i * this._length;
                let endOffset = startOffset + this._length;
                this._channelData[i] =
                    new Float32Array(this._module.memory.buffer).subarray(startOffset, endOffset);
            }
        }

        /**
         * Adapt the current channel count to the new input buffer.
         *
         * @param  {number} newChannelCount The new channel count.
         */
        adaptChannel(newChannelCount) {
            if (newChannelCount < this._maxChannelCount) {
                this._channelCount = newChannelCount;
            }
        }

        /**
         * Getter for the buffer length in frames.
         *
         * @return {?number} Buffer length in frames.
         */
        get length() {
            return this._isInitialized ? this._length : null;
        }

        /**
         * Getter for the number of channels.
         *
         * @return {?number} Buffer length in frames.
         */
        get numberOfChannels() {
            return this._isInitialized ? this._channelCount : null;
        }

        /**
         * Getter for the maxixmum number of channels allowed for the instance.
         *
         * @return {?number} Buffer length in frames.
         */
        get maxChannelCount() {
            return this._isInitialized ? this._maxChannelCount : null;
        }

        /**
         * Returns a Float32Array object for a given channel index. If the channel
         * index is undefined, it returns the reference to the entire array of channel
         * data.
         *
         * @param  {number|undefined} channelIndex Channel index.
         * @return {?Array} a channel data array or an
         * array of channel data.
         */
        getChannelData(channelIndex) {
            // console.log(this._channelData);
            if (channelIndex >= this._channelCount) {
                return null;
            }

            return typeof channelIndex === 'undefined'
                ? this._channelData : this._channelData[channelIndex];
        }

        setChannelData(input, channelIndex) {
            this._channelData[channelIndex] = input[channelIndex];
        }

        setChannelOutputData(output, channelIndex) {
            // let output =
            output = this._channelData[channelIndex];
        }

        /**
         * Returns the base address of the allocated memory space in the WASM heap.
         *
         * @return {number} WASM Heap address.
         */
        getHeapAddress() {
            return this._dataPtr;
        }

        /**
         * Frees the allocated memory space in the WASM heap.
         */
        free() {
            this._isInitialized = false;
            this._module.stackFree(this._dataPtr);
            this._module.stackFree(this._pointerArrayPtr);
            this._channelData = null;
        }
    } // class HeapAudioBuffer
    return HeapAudioBuffer;
}
export default getHeapAudioBuffer;